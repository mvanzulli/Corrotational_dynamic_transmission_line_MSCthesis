\chapter{Metodología}
\linenumbers
\section{Aspectos de modelado computacional}
\subsection{Ecuación de equilibrio}

En esta sección se desarrolla la ecuación de equilibrio del sistema dinámico con valores de fuerzas externas, internas e inerciales. No se ha encontrado registros de este planteo analítico en la referencia consultada. Resulta imprescindible formular esta deducción para comprender los argumentos e hipótesis que subyacen al las expresiones descritas en \citep{Le2014}. Por añadidura, se construye paso a paso la linealización aplicada a la ecuación de movimiento no lineal, insumo fundamental para el abordaje numérico. 

Para cada punto del cuerpo debe cumplirse el balance vectorial entre fuerzas internas $\bf{f}_{int}$, inerciales $\bf{f}_{ine}$ y externas $\bf{f}_{ext}$. Este equilibrio es equivalente al postulado de PTV donde el diferencial energía interna y cinética se debe a un trabajo externo. La Ecuación de balance \eqref{Eq:MET:EquilibrioExacto} debe satisfacerse para todo instante temporal, en particular para $t+\Delta_t$. Dadas determinadas propiedades materiales y geométricas en la configuración de referencia, las fuerzas dependen de las magnitudes cinemáticas globales en ese instante: desplazamientos $\bf{d}$ $(t+\Delta_t)$, velocidades $\dot{\bf{d}}$ $(t+\Delta_t)$ y aceleraciones $\ddot{\bf{d}}$ $(t+\Delta_t)$. Es plausible entonces plasmarlo matemáticamente de manera exácta en la Ecuación \eqref{Eq:MET:EquilibrioExacto}.

\begin{equation}\label{Eq:MET:EquilibrioExacto}
	\bf{f}_{ext,t+\Delta_t}-\bf{f}_{int}(\bf{d}\text{$(t+\Delta_t)$})-\bf{f}_{ine}(\bf{d} \text{$(t+\Delta_t)$},\dot{\bf{d}}\text{$(t+\Delta_t)$},\ddot{\bf{d}}(t+\Delta_t))
	=0
\end{equation}
Los métodos numéricos a groso modo construyen una sucesión que al discretizar infinitamente converge a la solución exacta. El método de Newton-Raphson (N-R) vectorial consiste en linealizar una ecuación a través de su diferencial de primer orden. Esta aproximación tiene como consecuencia que la Ecuación \eqref{Eq:MET:EquilibrioExacto} ya no será nula sino igual a un resto $\bf{r}$. A su vez tal y como se detalla en las Ecuaciones \eqref{Eq:MET:AproxVel} y \eqref{Eq:MET:AproxAcel}, los métodos numéricos para la solución de problemas dinámicos, escriben las variables de aceleración y velocidad en función de los desplazamientos. Por lo tanto, el vector resto depende unicamente de dicha magnitud. Para diferenciar las variables aproximadas de las exactas se introduce la siguiente nomenclatura: ($\bf{d}\text{$(t+\Delta_t)$}$ $\rightarrow$ $\bf{d}_{t+\Delta_t}$), ($\dot{\bf{d}}\text{$(t+\Delta_t)$}$ $\rightarrow$ $\dot{\bf{d}}_{t+\Delta_t}$) y ($\ddot{\bf{d}}\text{$(t+\Delta_t)$}$ $\rightarrow$ $\ddot{\bf{d}}_{t+\Delta_t}$). 


\begin{eqnarray}\label{Eq:MET:AproxVel}
\dot{\bf{d}}_{t+\Delta_t}&=&F_v(\bf{d_t})\\
\label{Eq:MET:AproxAcel}
\ddot{\bf{d}}_{t+\Delta_t}&=&F_a(\bf{d_t})
\end{eqnarray}

Dado lo descrito anteriormente se buscan las aproximaciones cinemáticas tal que el residuo para un instante $t +\Delta_t$ sea próximo al vector nulo. Esto epxresa matemáticamente en Ecuación \eqref{Eq:MET:Resto}.
\begin{equation}\label{Eq:MET:Resto}
\begin{split}
	\bf{r}(\bf{d}_{t+\Delta_t})&=(-\bf{f}_{ext,t+\Delta_t}+\bf{f}_{int}(\bf{d}_{t+\Delta_t})+...\\	
	&...+\bf{f}_{ine}(\bf{d_{t+\Delta_t}},\dot{\bf{d}}_{t+\Delta_t}(d_{t+\Delta_t},\bf{d_t},\bf{\dot{d}_t},\bf{\ddot{d}_t}),
	\ddot{\bf{d}}_{t+\Delta_t}(d_{t+\Delta_t},\bf{d_t},\bf{\dot{d}_t},\bf{\ddot{d}_t}))
	\approx 0
\end{split}
\end{equation}

Por otro lado, según el método de N-R presentado en \cite{quarteroni2010numerical} es posible construir una sucesión iterativa en  $k$ de forma tal que en el paso siguiente, el vector resto se acerca el nulo. Realizando una aproximación de Taylor a la función se obtiene la siguiente expresión:

\begin{equation}\label{Eq:MET:Residuo}
	\bf{r}(\bf{d}^{k+1}_{t+\Delta_t})=\bf{r}(\bf{d}^k_{t+\Delta_t}) +
	\frac{\partial  \bf{r}(\bf{d}_{t+\Delta_t})}{\partial
		\bf{d}_{t+\Delta_t}}|_k~\Delta \bf{d}^{k+1}_{t+\Delta_t}=0
\end{equation}

Para calcular la derivada del residuo se utiliza la regla de la cadena aplicada a las funciones de velocidades y aceleraciones respecto de los desplazamientos. De manera general, se denominan a las derivadas vectoriales 

\begin{equation}\label{Eq:MET:DerivadaResiduo}
	\begin{split}
	\frac{\partial  \bf{r}(\bf{d}_{t+\Delta_t})}{\partial
	\bf{d}_{t+\Delta_t}}&=\frac{\partial  \bf{r}}{\partial
	\bf{\dot{d}}_{t+\Delta_t}}\frac{\partial 
	\bf{\bf{\dot{d}}_{t+\Delta_t}}}{\partial \bf{{d}}_{t+\Delta_t}}+ \frac{\partial 
	\bf{r}}{\partial \bf{\ddot{d}}_{t+\Delta_t}}\frac{\partial 
	\bf{\bf{\ddot{d}}_{t+\Delta_t}}}{\partial \bf{{d}}_{t+\Delta_t}}+\frac{\partial 
	\bf{r}}{\partial \bf{{d}}_{t+\Delta_t}}\\
	\frac{\partial  \bf{r}(\bf{d}_{t+\Delta_t})}{\partial \bf{d}_{t+\Delta_t}}&= \frac{\partial  \bf{r}}{\partial\bf{\dot{d}}_{t+\Delta_t}}\frac{\partial F_v}{\partial \bf{{d}}_{t+\Delta_t}}+\frac{\partial  \bf{r}}{\partial\bf{\ddot{d}}_{t+\Delta_t}}\frac{\partial F_a}{\partial \bf{{d}}_{t+\Delta_t}}+\frac{\partial 
		\bf{r}}{\partial \bf{{d}}_{t+\Delta_t}}
	\end{split}
\end{equation}

Las derivadas de la función residuo respecto de desplazamientos, velocidades y aceleraciones son las matrices tangentes descritas en la Sección \ref{Subsec:PRE:DinamicCorrot}. Incorporando $\bf{K_g}$ $\bf{M}$ y $\bf{C_k}$ se llega a:

\begin{equation}\label{Eq:PRE:DerivadaResiduo}
	\frac{\partial  \bf{r}(\bf{d}_{t+\Delta_t})}{\partial \bf{d}_{t+\Delta_t}}\Big|_k~
	= \left (\bf{K}_g+\frac{\partial\text{$ F_a$}}{\partial \bf{{d}}_{t+\Delta_t}}\bf{M} + \frac{\partial\text{$ F_v$}}{\partial \bf{{d}}_{t+\Delta_t}}\bf{C}_k \right)\Big|_k
\end{equation}

Sustituyendo la expresión anterior en la Ecuación \eqref{Eq:PRE:DerivadaResiduo} de N-R se halla el paso en desplazamientos en $k+1$ a partir de las magnitudes en k $\Delta \bf{d}^{k+1}_{t+\Delta_t}=$. Matemáticamente:



\begin{equation}\label{Eq:Pre:Incremento}
	\left (\bf{K}_g+\frac{\partial\text{$ F_a$}}{\partial \bf{{d}}_{t+\Delta_t}}\bf{M} + \frac{\partial\text{$ F_v$}}{\partial \bf{{d}}_{t+\Delta_t}}\bf{C}_k \right)\Big|_k^{-1} \left(-\bf{r}(\bf{d}^k_{t+\Delta_t})\right)=  \Delta\bf{d}^{k+1}_{t+\Delta_t}
\end{equation}

Una vez planteada la ecuación de equilibrio no lineal y su método de resolución numérico hace falta conocer explícitamente las funciones $F_a$ y $F_v$. Para esto se implementó el método de HHT presentado a continuación en La sección \ref{Sec:MET:HHT}. 



\subsection{Resolución numérica mediante HHT}\label{Sec:MET:HHT}
%
 Este método consiste en una innovadora propuesta respecto del algoritmo de Newmark presentado en \cite{newmark1959method}. Según el articulo \cite{hilber1977improved} el método de HHT, es incondicionalmente estable para la integración de ecuaciones dinámicas en el área estructural. Esto implica que el paso de tiempo puede incrementarse considerablemente conservando la convergencia numérica del método numérico. Además de esta ventaja, cuando se buscan representar modos de baja frecuencia, el factor de disipación que atenúa la energía del sistema, no depende del incremento de tiempo elegido. Complementario a esto,  evita la aparición indeseada de altas frecuencias numéricas, sin eliminar los modos de baja frecuencia endógenos a la estructura. 
 
 En la publicación \citep{hilber1977improved}  se compara el método de HHT con otros métodos del clásicos en el área de análisis numérico estructural como ser: el método del trapecio, el de Wilson y la familia de algoritmos de Newmark:. El autor concluye que HHT además de su mayor grado de ajuste, es mas preciso para bajas frecuencias. Dado que esto se ajusta a la perfección para la aplicación de conductores y considerando lo implementado en \cite{Le2014} se decidió implementar este método numérico.   
 
 Primeramente se deben distinguir las magnitudes lineales de las angulares, para esto se utiliza la nomenclatura $\bf{d}=(\bf{u},\bf{w}$). Se presentan entonces las funciones de aproximación para aceleraciones y velocidades lineales globales en función de los desplazamientos. Estas ecuaciones se escribirán inicialmente en términos de los parámetros de Newmark $\alpha$ y $\beta$. Por ende las funciones de actualizacion para el instante $t+\Delta_T$ se escriben:
 

 \begin{eqnarray}
 \label{Eq:MET:AproxAceleracion}
 \ddot{\bf{u}}_{t+\Delta t}
 &=&
 \frac{1}{\alpha_{NW}(\Delta t)^2} \bf{u}_{t+\Delta t}
 - \frac{1}{\alpha_{NW} (\Delta t)^2} \bf{u}_{t} 
 - \frac{1}{\alpha_{NW} (\Delta t)  } \dot{\bf{u}}_{t} 
 - \frac{1}{2 \alpha_{NW}}  (1-2\alpha_{NW} ) \ddot{\bf{u}}_{t}   \\
 \label{Eq:MET:AproxVelcoity}
 \dot{\bf{u}}_{t+\Delta t}& =&
 \frac{\beta_{NW}}{\alpha_{NW} (\Delta t)} \bf{u}_{t+\Delta t}
 - \frac{\beta_{NW}}{\alpha_{NW} (\Delta t)} \bf{u}_{t}
 + \left( 1 - \frac{\beta_{NW}}{\alpha_{NW}} \right) \dot{\bf{y}}_{t}
 + \left( 1- \frac{\beta_{NW}}{2 \alpha_{NW}} \right) \ddot{\bf{u}}_{t} \Delta t
 \end{eqnarray}  

Para implementar HHT basta unicamente con definir los parámetros $\alpha_{NW}$ y $\beta_{NW}$ en términos del valor de $\alpha_{HHT}$. Esto se realiza mediante las Ecuaciones \eqref{Eq:MET:betaNW} y \eqref{Eq:MET:alphaNW}. En estas funciones es posible notar las equivalencias y similitudes entre los métodos. El de Newmark clásico con $\beta_{NW}=1/2$ y $\alpha_{NW} =1/4$ se logra ajustando el parámetro $\alpha_{HHT}=0$. 

\begin{eqnarray}
	\label{Eq:MET:betaNW}
 	\beta_{NW} &=& \frac{1-2\alpha_{HHT}}{2}\\
 	\label{Eq:MET:alphaNW}
 	\alpha_{NW} &=& \frac{(1-\alpha_{HHT})^2}{4}
\end{eqnarray}

Se calculan entonces las derivadas respecto al desplazamiento para las funciones de aproximación. Estas se expresan en función del parámetro $\alpha_{HHT}$ el incremento $\Delta_T$ ente dos tiempos consecutivos $t$ y $t+\Delta_t$.

\begin{eqnarray}
\label{Eq:Met:DerivadasAcelLinear}
\frac{\partial \bf{\ddot{u}_{t+\Delta t}}}{\partial \bf{{u}_{t+\Delta_T}}}& = &
\frac{4}{(1-\alpha_{HHT})^2 \Delta_T^2}\\
\label{Eq:Met:DerivadasVelLinear}
\frac{\partial \bf{\dot{u}_{t+\Delta_t}}}{\partial \bf{{u}_{t+\Delta_T}}}& = &
\frac{1-\alpha_{HHT}}{2\Delta_T}
\end{eqnarray}

A diferencia de la aproximación para velocidades y aceleraciones lineales, las magnitudes angulares deben actualizarse mediante otras funciones. Este tipo de variables no cumple la aditividad algebraica y la propiedad de conmutativiad. Es por esto, que los vector de velocidades y aceleraciones angulares para paso $k+1$, en el instante $t+\Delta_t$, deben calcularse según  las Ecuaciones \eqref{Eq:MET:ActualizacionesAngulares1} y \eqref{Eq:MET:ActualizacionesAngulares2} presentadas en la referencia \citep{ibrahimbegovic1998finite}. 


 \begin{eqnarray}\label{Eq:MET:ActualizacionesAngulares1}
 	\dot{\bf{w}}_{t+\Delta t}&=&\bf{\Lambda}_{t+\Delta
 		t}^g\left[\frac{\alpha}{\beta\Delta_t}\bf{\theta}_{t+\Delta_t}+
 	\frac{\beta-\alpha}{\beta}\bf{\dot{w_t}+\frac{(\beta-0.5\alpha)\Delta_t}{\beta}}
 	\ddot{\bf{w}}_{t} \right ]\\\label{Eq:MET:ActualizacionesAngulares2}
 	\ddot{\bf{w}}_{t+\Delta t}&=&\bf{\Lambda}_{t+\Delta
 		t}^g\left[\frac{1}{\beta\Delta_t^2}\bf{\theta}_{t+\Delta_t}-
 	\frac{1}{\beta\Delta_t}\bf{\dot{w_t}-\frac{(0.5-\beta)}{\beta}}
 	\ddot{\bf{w}}_{t+\Delta t} \right ]
 \end{eqnarray}

En las Ecuaciones \eqref{Eq:MET:ActualizacionesAngulares1} y \eqref{Eq:MET:ActualizacionesAngulares2} la transformación $\bf{\Lambda}_{t+\Delta t}^g$ es la composición de las rotaciones globales para dos instantes consecutivos: 

\begin{equation}\label{Eq:Met:CalculodeLamda}
	\bf{\Lambda}_{t+\Delta
		t}^g=\exp({\widetilde{\bf{\theta_{t+\Delta_t}^g}}})=\bf{R}^g_{t+\Delta_t}(\bf{R}^g_{t})^T
\end{equation}

Análogamente a las derivadas de las funciones lineales se calculan las angulares. Esto se obtiene a partir de la derivación analítica de las Ecuaciones expresiones \eqref{Eq:MET:ActualizacionesAngulares1} y \eqref{Eq:MET:ActualizacionesAngulares2}.

\begin{eqnarray}
	\label{Eq:MET:DerivadasAngulares1}
	\frac{\partial \bf{\ddot{w}_{t+\Delta T}}}{\partial \bf{{w}_{t+\Delta_t}}}& = 
	\frac{4}{(1-\alpha_{HHT})^2 \Delta_T^2}&  \bf{T_s^{-T}}(\bf{\theta^g_{1,{t+\Delta_t}}})\\
	\label{Eq:MET:DerivadasAngulares2}
	\frac{\partial \bf{\dot{w}_{t+\Delta_T}}}{\partial \bf{{w}_{t+\Delta t}}}& = 
	\frac{1-\alpha_{HHT}}{2\Delta_T}& \bf{T_s^{-T}}(\bf{\theta^g_{1,{t+\Delta_t}}})
\end{eqnarray}



Es posible compactar las derivadas lineales y angulares de las Ecuaciones \eqref{Eq:MET:DerivadasAngulares1}, \eqref{Eq:MET:DerivadasAngulares2}, \eqref{Eq:Met:DerivadasAcelLinear} y \eqref{Eq:Met:DerivadasVelLinear} al definir convenientemente la matriz $\bf{B_t}$. En función de esta es posible escribir los incrementos del vector de velocidades y aclaraciones globales en función del incremento en desplazamiento. Estas relaciones se expresan a continuación:
	 
\begin{eqnarray}
	\label{Eq:MET:DefBt}
	\bf{B}_t & = & \bf{\begin{bmatrix}
			I& 0 & 0 & 0\\ 
			0 & \bf{T_s^{-T}}(\bf{\theta^g_{1,{t+\Delta_t}}}) & 0 & 0\\ 
			0& 0 & I & 0\\ 
			0 & 0 & 0 & \bf{T_s^{-T}}(\bf{\theta^g_{2,{t+\Delta_t}}})
	\end{bmatrix}}\\
	\label{Eq:MET:IncrementoVelGlobalBt}
	\Delta \dot{\bf{d_g}}&=& \left(\frac{1-\alpha_{HHT}}{2\Delta_T} \bf{B_t}\right) \Delta
	\bf{d_{g,{t+\Delta_t}}}\\
	\label{Eq:MET:IncrementoAcelGlobalBt}
	\Delta \ddot{\bf{d_g}}&=& \left( \frac{4}{(1-\alpha_{HHT})^2 \Delta_T^2} \bf{B_t} \right)\Delta
	\bf{d_{g,{t+\Delta_t}}}
\end{eqnarray}	



Al dividir las Ecuaciones \eqref{Eq:MET:IncrementoVelGlobalBt} y \eqref{Eq:MET:IncrementoAcelGlobalBt} se obtienen las funciones $F_a$ y $F_v$. Estas relaciones matemática debe integrarse a la Ecuación linealizada de equilibrio \eqref{Eq:Pre:Incremento} para obtener el paso en desplazamientos para la iteración en el instante $t+\Delta_T$. Finalmente eso se plantea en la Ecuación \eqref{Eq:MET:FinalIncremento}.


\begin{equation}\label{Eq:MET:FinalIncremento}
	\bf{r}(\bf{d}^k_{t+\Delta_t})=  -\left
	(\bf{K}_g+\text{$\left( \frac{4}{(1-\alpha_{HHT})^2\Delta_T^2} \right)$} \bf{M}\bf{B}_t + \left(\text{$\frac{1-\alpha_{HHT}}{2\Delta_T}$}\right) \bf{C}_k \bf{B}_t \right)\Delta\bf{d}^{k+1}_{t+\Delta_t}
\end{equation}

Se aclara que una para obtener el valor inceremental en desplazamientos la matriz entre paréntesis curvos debe invertirse y por tanto ser no singular. De lo contrario, el método podría presentar un número de condición nulo arrojando infinitas soluciones o ninguna.  Esto se encuentra garantizado por la naturaleza de las matrices que la integran (de masa, centrifuga y tangente). Las matrices tangentes fueron simetrizadas como se aclaró anteriormente para mantener el orden de convergencia. Las matrices centrifugas y de masa devienen de un potencial asociado (la energía cinética) como los parámetros $\alpha_{HHT}$ son menores a uno, en general en el intervalo $[-0.1;0.1]$, la suma de esta matrices suele ser definidas positivas. Por lo que $\bf{K}_{tot}$ será invertible. Se aclara que para este trabajo, si bien se consideraron las funciones de actualización angulares para los incrementos, el angulo se sumo de forma aditiva. 

\subsection{Implementación numérica en ONSAS}
En la sección que prosigue se detallan los códigos implementados en la librería de software libre: \emph{Open Non Linear Structural Analysis Solver} (\href{https://github.com/ONSAS/ONSAS/}{ONSAS}). Se destaca lo valioso de incorporarar el elemento corrotacional a una librería de software abierto. \href{https://github.com/ONSAS/ONSAS/}{ONSAS} es una herramienta general que permite integrar distintos elementos dentro del mismo modelo, resolver mediante diversos algoritmos numéricos y visualizar gráficamente las salidas en 3D a través del programa de código abierto Paraview.

Las líneas de código relacionadas con la formulación local, las funciones matriciales de rotación, las fuerzas internas y sus matrices tangentes fueron aportadas por el Dr. Jean Mark Battini. Su intervención constituye uno de los pilares fundamentales no solo por ser pionero dela formulación corrotacional aplicada a estructuras, publicadas en los trabajos \citep{Battini2002} \citep{Le2014} sino también por su predisposición a difundir los códigos de su investigación, cuyo valor es invaluable. A continuación en \ref{Pseudo:MET:Corrot} se detalla un pseudo-código panorámico sobre la librería general ejecutada en \href{https://github.com/ONSAS/ONSAS/}{ONSAS}. 

\begin{algorithm}\label{Pseudo:MET:Corrot}
	\begin{algorithmic} 
		\REQUIRE: $tol_r$, $tol_u$, $\text{maxIter}$, $\Delta_T$, $\alpha_{HHT}$
		\STATE Iniciar cinemáticas: $\bf{d_t}\xleftarrow[]{}\bf{d_0}$
		$\bf{\dot{d}_t}\xleftarrow[]{}\bf{\dot{d}_0}$
		$\bf{\ddot{d}_t}\xleftarrow[]{}\bf{\ddot{d}_0}$ 
		\STATE Iniciar tiempo: $t\xleftarrow{}t_0$
		\WHILE {$t<t_f$}
			\STATE finDisp = $0$
			\STATE Definir: $\bf{d^k}\xleftarrow[]{}\bf{d_t}$, $\bf{\dot{d}^k}\xleftarrow[]{}\bf{\dot{d}_t}$, $\bf{\ddot{d}^k}\xleftarrow[]{}\bf{\ddot{d}_t}$.
			\STATE Evaluar $\bf{f_{ext,t+\Delta t}}$	
			\WHILE{FinDisp = 0}
				\STATE Calcular fuerzas: $\bf{f}_{ine}^k(\bf{d}^k,\bf{\dot{d}}^k,\bf{\ddot{d}}^k)$,  $\bf{f}_{int}^k(\bf{d}^k)$ y $\bf{res}^{k}(\bf{d}^k,\bf{\dot{d}}^k,\bf{\ddot{d}}^k)$. 
				\STATE Calcular y ensamblar matrices Tangentes: $\bf{K}_g^k$ $\bf{M}^k$  $\bf{C}_k^k$. 
				\STATE Despejar $\Delta \bf{d}^{k+1}$ 
				\STATE Actualizar desplazamientos globales:  $\bf{d}^{k+1} = \bf{d}^{k} + \Delta\bf{d}^{k+1}$ 
				\STATE Recalcular velocidades y aceleraciones lineales: ($\bf{\dot{u}}^{k+1}$), ($\bf{\ddot{u}}^{k+1}$).
				\STATE Recalcular velocidades y aceleraciones angulares: ($\bf{\dot{w}}^{k+1}$), ($\bf{\ddot{w}}^{k+1}$).
				\STATE Ensamblar velocidades: $\bf{\dot{d}}^{k+1}$ $\leftarrow$ ($\bf{\dot{u}}^{k+1}$,$\bf{\dot{w}}^{k+1}$)
				\STATE Ensamblar aceleraciones: $\bf{\ddot{d}}^{k+1}$ $\leftarrow$ ($\bf{\ddot{u}}^{k+1}$,$\bf{\ddot{w}}^{k+1}$)
´				\STATE Actualizar fuerzas: $\bf{f}_{ine}^{k+1}(\bf{d}^{k+1},\bf{\dot{d}}^{k+1},\bf{\ddot{d}}^{k+1})$,  $\bf{f}_{int}^{k+1}(\bf{u}^{k+1})$ y $\bf{res}(\bf{d}^{k+1})$. 
				\STATE Calcular: 
				\IF {$\left \| \Delta \bf{d}^{k+1} \right \|< tol_d \left \| 
					\bf{d}^{k+1} \right \| $  $~V~$ $\left \| \bf{res}(\bf{d}^{k+1}) \right \|<tol_r \left \| \bf{f}_{ext} \right \| $  $~V~$ $ \text{k}\geq \text{max}_{iter}$ }
				\STATE finDisp = 1
				\ENDIF
			\ENDWHILE
			\STATE Actualizar $\bf{d_{t}}\xleftarrow[]{}\bf{d^{k+1}_{t+\Delta_T}}$, $\bf{\dot{d}_{t}}\xleftarrow[]{}\bf{\dot{d}^{k+1}_{t+\Delta_T}}$, $\bf{\ddot{d}_t}\xleftarrow[]{}\bf{\ddot{d}^{k+1}_{t+\Delta_T}}$.
			\STATE $t = t+\Delta_T$	
 		\ENDWHILE
	\end{algorithmic}
\caption{Pseudocódigo de iteración general. }
\end{algorithm}

En la estructura de códigos anterior se observan dos bucles en simultaneo. Inicialmente se ejecuta un primer $\bf{while}$ de avance cronológico que permite incrementar la variable temporal en pasos de $Delta_T$ y evaluar los valores que son constantes en el tiempo, como ser: el valor de $\bf{f}_{ext}$. Para resolver el estado del sistema en el tiempo $t+\Delta T$ hace falta resolver la ecuación no lineal de resto descrita en la Expresión \eqref{Eq:MET:Resto}. Para esto, se construye una sucesión en desplazamientos que tienda a la solución para ese paso, esto se realiza mediante (N-R) en el segundo $\bf{while}$ en desplazamientos. Para este bucle en el pseudocódigo \ref{Pseudo:MET:Corrot} se omitió la notación en $t+\Delta T$ para simplificar, mas todas las variables se corresponden a dicho tiempo.

Esta parte del código se pudría subdividir en dos estructuras, primeramente el cálculo del incremento que determina el paso $k+1$, a partir de los desplazamientos en el paso actual $k$. Luego se actualizan las variables cinemáticas de desplazamientos, velocidades y aceleraciones. Este conjunto de pasos se realiza mientras que la variable boolena finDisp sea nula. La alteración de su valor se encuentra atada a la operación lógica de la sentencia $\bf{if}$. Esta se rige por la operación lógica disyunta de tolerancias en desplazamientos $tol_u$, en vector de fueras residuales $tol_{res}$ y número máximo de iteraciones $max_{Iter}$. Las primeras dos son relativas al valor de fuerzas externas y desplazamientos, lográndose de este modo independizarse de las magnitudes absolutas desconocidas. Una vez que el segundo bucle en desplazamientos converge, la variable finDisp alcanza la unidad y se tanto el valor del tiempo como las magnitudes cinemáticas para el instante siguiente.

Habiendo explicado la estructura general del código resulta importante profundizar y desplegar el cálculo de la función de fuerzas inerciales y matrices dinámicas tangentes. Este código se agregó a \href{https://github.com/ONSAS/ONSAS/}{ONSAS} procurando un análisis general para aplicaciones futuras que trascienden al alcance y foco de este trabajo. Se presenta a continuación un esquema tipo pseudocódigo de la función \href{https://github.com/ONSAS/ONSAS/blob/master/src/elementBeamForces.m}{elementbeamforces.m} disponible.

\begin{algorithm}\label{Pseudo:MET:elementBeamForces}
	\begin{algorithmic} 
	\REQUIRE $A_{\rho}$ $\bf{I}_{\rho}^{ref}$ $E$ $\nu$ $G$ $\bf{X}_1$ $\bf{X}_2$ $\bf{d}_g^e$
		 \FOR{1 \TO $N_{elem}$ } 
		 	\STATE Separar vector desplazamientos $\bf{d}_g=(\bf{u}^g,\bf{w}^g)$
			\STATE ----------------$ \text{Cálculo de matrices de rotación } $---------------- 
			\STATE Computar matrices de rotación global $\bf{R}_g^1$ y $\bf{R}_g^2$
			\STATE Evaluar matriz de rotación de referencia $\bf{R}_o$
			\STATE Hallar $\bf{q}_1$ $\bf{q}_2$ $\bf{q}$ y calcular $\bf{e}_1$ $\bf{e}_2$ y $\bf{e}_3$.
			\STATE Evaluar maitrz de rotación rígida $\bf{R_r}$
			\STATE Calcular matrices de rotación locales $\bf{R}_i = \bf{R}_r^T \bf{R}_g^i \bf{R}_o$
			\STATE -----------------------------------------------------------------------------  
			\STATE --------- $\text{Cálculo de fuerza interna y matriz tangente } $---------
			\STATE Calcular largos iniciales, actuales y estiramiento $l_0$ y $l$ $u=l-l_0$
			\STATE Invertir $\bf{R}_i$ y hallar ángulos locales $\bf{\bar{\theta}_i}$.
			\STATE Ejecutar \emph{beamLocalStaticForces } para fuerza interna $\bf{f}_{int}^{loc}$ y matriz tangente local $\bf{K}_{T}^{loc}$.
			\STATE Construir matrices auxiliares: $\bf{H}$ $\bf{G}$ $\bf{P}$ $\bf{B}$  $\bf{r}$ 
			\STATE Transformar a coordenadas globales:  $\bf{K}_{T}^{g}\leftarrow\bf{K}_{T}^{loc}$ y $\bf{f}_{int}^{g}\leftarrow\bf{f}_{int}^{loc}$.
			\STATE -----------------------------------------------------------------------------  
			\STATE ------ $\text{Cálculo de fuerza inerciales y matrices dinámcias} $------
			\STATE Todas las variables dependen de la coordenada (x)
			\STATE Definir funciones de interpolación $N_i$
			\STATE Calcular matrices: $\bf{P_1}(x)$, $\bf{P_2}$, $\bf{N}$ y $\bf{H}_1$.
			\STATE Hallar velocidades  $\dot{\bf{w}}$, $\dot{\bf{u}}$ y $\dot{\bf{w}}_r$ 
			\STATE Calcular matrices auxiliares: $\bf{H}_1$, $\dot{\bf{H}}_1$, $\bf{H}_2$, $\dot{\bf{H}}_2$, $\bf{C}_1$, $\bf{C}_2$, $\bf{C}_3$ y $\bf{C}_4$.        
			\STATE Hallar las aceleraciones: $\ddot{\bf{w}}$  $\ddot{\bf{u}}$.
			\STATE Girar el tensor de inercia a la configuración deformada: $\bf{I}_{\rho}$ $\leftarrow$ $\bf{I}_{\rho}^{ref}$
			\STATE Hallar expresiones e integrar en el elemento: $\bf{f}_{ine}$ $\bf{M}$ y $\bf{C}_k$
			\STATE  Ensamblar : $\bf{f}_{ine}$ $\bf{M}$, $\bf{C}_k$ $\bf{K}_{T}^{g}$ $\bf{f}_{int}^{g}$
			\STATE -----------------------------------------------------------------------------  
		\ENDFOR 
	\end{algorithmic}
	\caption{Pseudocódigo elementBeamForces. }
\end{algorithm}

En el diagrama presentado anteriormente en el Pseudocódigo \ref{Pseudo:MET:elementBeamForces} se observan tres divisiones principales. Esto ordena el código consecutivamente según el desarrollo constructivo de las variables intervinientes. Primeramente se hallan las matrices de rotación que permiten vincular las magnitudes a cada una de las configuraciones: de referencia, rígida y deformada. Una vez representadas estas transformaciones, se procede a calcular las fuerzas interna y las matrices tangentes en la configuración local a través de la función \href{https://github.com/ONSAS/ONSAS/blob/master/src/beamLocalStaticForces.m}{beamLocalStaticForces}. Desafortunadamente tanto entradas como salidas de escrita función se encuentra referida al sistema de coordenadas locales. Es por esto que resulta inevitable calcular los angulos y desplazamientos locales. Asimismo transformar las salidas a coordenadas globales para integrar al código general expuesto en \ref{Pseudo:MET:Corrot}.

De forma subsiguiente se arman las matrices dinámicas y los vectores de fuerza inercial asociadas al elemento. Con este fin, se calculan las expresiones analíticas de las magnitudes cinemáticas en cada sección. Estas están referidas al baricentro ubicado a una distancia $x$ en la configuración de referencia.  Para esto se definen una serie de variables auxiliares y sus  respectivas derivadas.  

Una vez finalizado estos cálculos se integran las matrices tangentes y el vector de fuerzas inerciales, empleando el método de integración numérica de cuadratura de Gauss. Este se implementó con 3 puntos de integración. Por último, los valores obtenidos tanto para las matrices tangentes dinámicas y estáticas,  como los vectores de fuerza inercial e internas, en coordenadas globales, se ensamblan a las matrices de todo el sistema.
 
\section{Aspectos de modelado estructural}
\subsection{Condiciones iniciales y de borde}

\subsection{Modelo de viento}\label{Sec:PRE:Modeloviento}
Un cuerpo inmerso en un fluido en movimiento sufre determinadas cargas debido al campo de presiones en su superficie. Este campo suele producir fuerzas de arrastre (drag), en la dirección del flujo y fuerzas perpendiculares (lift). Las cargas de drag son el resultado de integrar las tensiones rasantes en la capa limite en toda la frontera del cuerpo. Mientras que las cargas de lift aparecen sobre el sólido debido a la asimetría del campo de presiones entre el intradós y extradós del sólido inmerso. Esta diferencia de presiones entre dos superficies contrarias del cuerpo genera una circulación circundante en el campo de velocidades relativos. Al integrar ese campo  en curva cerrada correspondiente a la silueta del cuerpo, se induce una fuerza. Ambos efectos dinámicos sobre el cable se ilustran en la Figura \ref{fig:MET:Viento:DragLift}. Para este trabajo la competente de lift se desprecia frente al drag.  Esto se debe a la simetría de revolución del cuerpo, esta garantiza que la circulación sea nula, lo que se traduce en que la fuerza lift sea insignificante respecto al arrastre. 

Por otra parte el flujo se consideró unidimensional según el eje $z$ en la Figura \ref{fig:MET:Viento:EsqViento}, siendo este el caso más amenazante para el conductor. Esta hipótesis proviene de diferentes trabajos publicados donde la componente perpendicular a la superficie terrestre o ascendente suele ser significativamente menor a la paralela \citep{duranona2009analysis} \citep{stengel2017measurements} \cite{yang2016nonlinear}. Esta premisa simplificadora supone que el sistema de trasmisión, en el tiempo inicial, se encuentra completamente perpendicular al sentido del viento, por ende la velocidad descarga su mayor fuerza sobre el sistema. 

Otra hipótesis a clarificar es que no se considera el cambio de orientación del cable respecto al viento. También se deprecia la velocidad relativa que el viento desarrolla respecto al cable y viceversa. Un sucinto análisis de este fenómeno se muestra en \ref{Sec:MET:Amort} 

Este escenario es el más peligroso y desafiante para la seguridad e integridad de la línea. Otro argumento posible a favor de esta hipótesis se sustenta en la mayor rigidez del cable en la dirección perpendicular al flujo, además del el peso que se opone a la fuerza de sustentación.
\begingroup
\begin{figure}[htbp]
	\centering
	\subfigure[Vista en perspetiva ]{	\def\svgwidth{60mm}
		\input{./imagenes/Metodologia/EsquemaViento.pdf_tex}}\label{fig:MET:Viento:EsqViento}
	\subfigure[Vista lateral ]{	\def\svgwidth{50mm}
		\input{./imagenes/Metodologia/DragLift.pdf_tex}}\label{fig:MET:Viento:DragLift}
	\caption{Ilustración del viento y sus efectos.} 	\label{fig:Met:Viento:Esquemas}
\end{figure}
\endgroup
La componente unidireccional del flujo puede ser desglosada en una termino medido y otro fluctuante $u_v(z,t)=u_m(z,t)+{u}'(z,t)$, por ende la velocidad media para un período $T$ toma la expresión de Ecuación \eqref{Eq:MET:ComponentsVel}:


\begin{equation}\label{Eq:MET:ComponentsVel}
	u_m(t)=\frac{1}{T}\int_{0}^{T}u_v(t)dt
\end{equation}


El valor del periodo $T$ debe ajustarse minimizando la desviación estándar asociada a la intensidad de turbulencia, esta se define como el cociente entre la desviación estándar de la velocidad fluctuante y  media para un instante de tiempo dado. Sin embargo para este trabajo no se consideran las fluctuaciones debido a la presencia de vórtices en el flujo, por lo que el valor de $T=1/30$ s se extrajo del artículo \citep{stengel2017measurements}.

Considerando el aire como un fluido no newtoneano indicado $\rho$ la densidad del aire a determinada temperatura, $C_d$ el coeficiente de drag para como función del número de Reynolds, entonces la fuerza media en el sentido del flujo (``drag'') para un elemento de diámetro $d_c$ y largo $l_e$ se calcula según la Expresión \eqref{Eq:MET:FuerzaViento}:

\begin{center}
	\begin{equation}
		\label{Eq:MET:FuerzaViento}
		F_v(t)=\int_{l_0}\frac{1}{2}{\rho (T)C_d(Re)d_cu_m(t)^2} dl= \frac{1}{2}\rho C_dd_cu_m(t)^2l_{e}
	\end{equation}
\end{center}



Para este cálculo se asumió como constante a las magnitudes al interior del elemento, es por esto que el valor de la integral es simplemente el producto del integrando por el largo del intervalo. Además se modeló como una fuerza nodal equivalente a la mita de $F_v$. Si bien la fuerza del viento es distribuida, los momentos nodales que estas inducen se cancelan con los elementos aledaños. Por otra parte los valores de $C_d$ se extrajeron de las referencias \citep{Foti2016} y se verificaron con el estudio para estos coeficientes durante tormentas conectivas \citep{mara2007effects}. La densidad $\rho$ se consideró la usual para presión atmosférica y una temperatura de $20$ ºC.

\subsubsection{Amortiguamiento aerodinámico}
 En este trabajo no se resuelve un sistema acoplado fluido-estructura. No obstante, es preciso notar determinadas consideraciones sobre el amortiguamiento aproximado introducido. Dada una sección arbitraria transversal al cable donde el viento tiene determinada componente axial y tranvseral a el conductor indicadas con el nombre $u$ y $v$.  

\begingroup
\begin{figure}[htbp]
	\centering
	\subfigure[[Esquema en sistema de referencias relativo. ]{	\def\svgwidth{80mm}
		\input{./imagenes/Metodologia/FuerzaZY.pdf_tex}}\label{fig:MET:Viento:FuerzaZY}
	\subfigure[Esquema en sistema de referencias absoluto. ]{	\def\svgwidth{80mm}
		\input{./imagenes/Metodologia/VelRel.pdf_tex}}\label{fig:MET:Viento:VelRel}
	\caption{Ilustración de fuerzas y velocidades} 	\label{fig:Met:Viento:EsquemasAmort}
\end{figure}
\endgroup
